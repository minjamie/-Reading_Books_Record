# Chapter 7: 정규화 이론

## 📌 그럼에도 불구하고 정규화 이론

- 데이터 모델링은 2차원 표에 어떤 데이터를 어떻게 담는 것인 최적인지 고민하는 과정

#### 데이터 집합을 '어떻게' 담는 것이 가장 적합한 걸까?

[학생들의 수강과목과 평가 결과를 담고 있는 표]![](https://images.velog.io/images/minj9_6/post/0e38fa51-d357-4eaf-8eb1-ab0e66a261cf/image.png)

위 표는 구조적으로 '데이터 이상 현상'이 존재한다.

#### 📖 데이터 이상 현상

> - 표를 구성하는 속성의 값을 수정할 때나 표에 새로운 개체를 삽입하거나 삭제할 때 *의도하지 않은 다른 데이터에 문제가 발생하는 현상*이다.

- 의도하지 않은 문제는 다음과 같다.

1. 평코드 결과가 없는 홍길동이라는 학생에 대한 정보는 입력 불가(특정 속성값이 null인 데이터 존재 할 수 없다는 가정하에)
2. 과목코드가 CR11인 과목의 이름이 '심리학입문'으로 변경되면 박영진과 김영희의 CR11 관련 열을 모두 찾아서 수정해야한다.
3. 김영희의 F학점 평가 결과를 삭제하면 논리학개론 과목도 함께 삭제된다.

=> 데이터를 어떻게 담아야 할까 고민할 때 이러한 `데이터 이상 현상`이 발생하지 않도록 해야한다.

#### 📋 정규화

- 데이터 이상 현상의 원인은 데이터가 독립적이지 않고 중복으로 관리되어 **데이터 간의 종속성**에 계속 영향을 받기 때문이다.
- 현실의 데이터는 대부분 종속 관계를 맺는데* 속성들의 **종속성**을 분석해서 하나의 종속성이 하나의 표(관계형 이론에선 릴레이션)로 관리되도록 분해하는 과정*이 **정규화**다.
- 즉, 종속성을 기준으로 데이터를 어떻게 담는 것이 최적인가에 대한 방법론이 바로 정규화 이론이다.

#### 이론대로 만들어진 모델의 특징

> 1. 하나의 종속성이 하나의 표로 분리되어 성격이 명확하다는 특징
> 2. 중복을 없애 데이터 이상 현상이 최소화되고, 데이터 무결성이 극대화된 구조

#### 함수 종속?

> - 하나의 집합 안에 존재하는 속성 사이의 연결 관계를 의미한다.

- 집합 내 속성 A가 속성 B의 값을 유일하게 식별하는 결정자라면 속성 B는 속성 A에 함수적으로 종속된다. 앞선 표에서 여러 종속 구조가 하나의 집합에 공존한다.
- 개별 종속성은 모두 별도로 분리하여, 즉 **정규화**하여 관리해야 데이터를 안정적인 구조로 관리할 수 있다.

EX>

- 종속성 1: 학번 -> 성명
- 종속성 2: 과목코드 -> 과목명
- 종속성 3: 학번 + 과목 코드 -> 평가코드

### 📚 1정규화 - 반복 속성, 다수의 값을 갖는 속성은 별도 엔터티로 분리한다.

![](https://images.velog.io/images/minj9_6/post/81aa0122-f9af-4b1f-876c-029044589c1b/image.png)

> - 모든 속성이 값을 반드시 하나만 가져야한다.

- 어떤 속성이 값을 여러개(다중 값 속성) 가지고 있거나 물리적으로는 하나만 갖지만 유사한 형태의 반복 속성이 존재하면(Ex> 자격증1, 자격증2....)해서 논리적으로는 다수의 값을 갖는 것과 마찬가지라면 Basic Parent에서 별도의 엔터티로 분리해야한다.

> ![](https://images.velog.io/images/minj9_6/post/8d38a3c1-89f2-4a3e-a668-a576153d60f0/image.png)

- 이미지 처럼 왼쪽의 사원 엔터니는 오른쪽 같이 두개의 엔터티로 분리해야한다.

> ![](https://images.velog.io/images/minj9_6/post/e9e4e885-9896-4e1a-ade4-09a27be2ba4e/image.png)

- 사원이 보유한 자격증 정보를 사원에 종속도니 정보가 아니라 독립된 개체 정보로 유일하게 관리할 경우

이 모델에서 특정 자격증에 대한 수당 지원 여부를 관리하고자한다면 <자격수당지원여부>속성은 개별 자격증에 종속된 개념이므로 <자격증> 엔터티에 두어야하며 반면 <자격증취득일자> 같은 속성은 자격증 보유자인 사원 정보까지 결합되어야 결정할 수 있으므로 <사원보유자격증>의 속성이다.

### 📚 2정규화 - 주 식별자 일부에만 종속된 속성은 별도의 엔터티로 분리한다.

![](https://images.velog.io/images/minj9_6/post/4ca969bc-c203-43ad-bda1-987c04a21820/image.png)

> - 모든 속성이 반드시 주 식별자 전부에 종속되어야한다.

- 1정규화로 생성된 집합은 자식이 되지만 2정규화로 분리된 집합은 부모가 된다.
  ![](https://images.velog.io/images/minj9_6/post/c625af89-5a1d-49ab-a224-4da36ede86b9/image.png)

> - 왼쪽 <계약> 엔터티에서 계약 주체는 <단체명> 혹은 <단체대표명>으로 표현된다면 이들 값이 변경되면 해당 단체의 모든 계약을 찾아서 바뀐 정보로 변경해줘야한다.

- 이는 <단체번호>에 종속된 <단체명>과 <단체대표자명> 속성이 <계약> 집합에 포함되어 있기 때문으로 정규화하여 오른쪽과 같이 별도의 <단체> 엔터티로 분리해야한다. 앞선 <사원보유자격증> 엔터티가 <사원>의 하위(자식) 엔터티로 분리된 것 달리, <단체> 엔터티가 계약의 상위(부모) 엔터티가 된다.

### 📚 제 3저유화 - 주 식별자 외의 모든 속성은 상호 독립적이어야한다.

> ![](https://images.velog.io/images/minj9_6/post/0ca2e268-d192-49a1-a66a-86d1f633b4e0/image.png)

- 주 식별자는 집합 내 속성의 결정자로서 집합의 성격을 규정하는 등 다양한 역할을 한다.
- 주 식별자가 아닌 모든 속성이 상호 종속관계여서는 안된다. 이미지에서 일반 속성인 ![](https://images.velog.io/images/minj9_6/post/97ff0393-d54a-4a2b-9234-14a654a13753/image.png)Attrib1과 Attrib2 사이에 종속서이 존재한다면 이들은 별도 엔터티로 분리해야한다.

![](https://images.velog.io/images/minj9_6/post/c70c88df-d255-454d-b60b-59eb08a29ef5/image.png)

- 정규화 적용 전 : 왼쪽 <주문> 엔터티의 일반 속성 중 <고객명>과 <고객등급> 속성은 <고객번호>에 함수적으로 종속되어있다.
- 정규화 적용 후 : 따라서 오른쪽 같이 고객 집합 집합을 별도로 분리하여 <고객> 엔터티로 만드는 과정이 필요하다
  📋

## 📌 정규화의 의의

현장에서 작성되는 데이터 모델을 검토하는 업무를 할 때 정규화 이론은 중요한 도구가 되어 모델을 검증해준다.

#### 📚 정규화 과정을 통해 정제된 '정규화 모델'의 특징

첫째, **속성 간의 종속성을 기준으로 성격이 유사한 속성들은 모이고 관계없는 속성들은 분리**된다.
=> 즉, 속성들이 자연스럽게 자기 자리를 찾게되면서 데이터 집합의 범주화가 이루어진다.

둘째, **하나의 주제로 집약된 데이터구조, 제대로 된 엔터티가 도출**된다. 정규화는 **함수 종속을 없애고 밀접한 속성을 하나의 표에 집약**시키는 체계적인 방법이다.
=> 데이터는 응집도는 높고 결합도는 낮게 분리되어 데이터 본질에 충실한 제대로된 엔터티가 도출된다.

셋째, **데이터 중복이 최소화된 효율적이고 구조화된 모델**이 나온다.
=> 중복에 다른 데이터 이상현상이 사라지며, 저장 용량 측면에서도 이익을 본다.

다섯째, 엔터티가 명확하고 정확해졌기에 **업무 변경에 따른 확장성**이 좋아진다.

여섯째, **데이터를 최적의 상태**로 담게된다. 데이터 중복을 최소함으로서 데이터 무결성을 극대화한다.

일곱째, 정규화된 모델은 그렇지 않은 모델에 비해 대부분 성능이 좋다.

## 📌 정규화와 관련된 성능 논쟁은 이제 그만

![](https://images.velog.io/images/minj9_6/post/50902e4e-ab12-4d3d-814c-a824a3638120/image.png)

정규화로 테이블 수와 조인의 양이 늘어난다해도 성능이 무조건 저하되는 것은 아니다.

> - 대부분의 DBMS는 데이터를 블록 단위로 읽고 쓰는데 하나의 블록에 다수의 행이 포함될 수 있다.

- IO의 최소 단위가 블록이기 때문에 SQL을 최적화할 때 조회할 레코드의 수가 아닌 블록의 수에 집착하는 이유가 바로 이 때문이다.
- 정규화를 통해 분리하면 블록하나가 이전보다 두 배나 많은 개체를 포함할 수 있게된다.
  이는 정규화 IO의 대상이 되는 블록수를 줄여줄 수 있음을 의미한다.

=> 한 블록에 더 많은 개체가 존재하면 메모리에 한 번 올라간 블록이 다시 사용될 확률도 그만큼 높이진다. 즉 적중률이 좋아진다.

즉, 정규화가 잘되있으면 훨씬 적은 블록을 읽고도 원하는 결과를 얻을 수 있다.

### \*💡conclusion

> - 정규화를 안다는 건 데이터의 종속성을 정확히 이해하고 그 관점으로 모델링을 전개한다는 뜻이다.
