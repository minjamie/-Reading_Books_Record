# 1장 자료구조
#### 1.0 인트로
코딩 처음 배울 시 올바르게 돌아가게 하는 것이 목표이며 **목표** 여야함

경험이 쌓이면 소프트웨어 공학자는 코드 **품질** 측면에서 또다른 계층들과 미묘한 차이를 익힘

코드 품질 척도 평가 기준
- 코드 유지 보수성 : 가독성, 조직, 코드 모듈성 같은 측면 포함
- 코드 효율성 : 같은 목표 달성해도 더 빠르게 실행되는 코드

- **효율적인** 코드 작성법을 다루는 책
- 더 빠르게 실행되는 코드 작성 능력을 갖춰야 함

빠른 코드 작성하는 첫 단계?
 >자료구조가 무엇인지, 다양한 자료 구조가 코드 속도에 어떤 영향을 미치는지 이해

 ##### 1.1 자료구조

- **데이터**? 모든 유형의 정보를 망라하는 용어로 가장 기초적인 수와 문자열로 이뤄짐
- 자료구조란? 데이터를 **조직**하는 방법으로 같은 데이터를 어떻게 다양한 방식으롤 조직하는지에 대해
- 데이터 조직이 **코드 실행 속도**에 미치는 영향이 크다


#### 1.2 배열: 기초 자료 구조
- **배열** ? 컴퓨터 과학에 기초적인 자료 구조 중 하나
- 배열 **크기**, 배열 데이터 원소가 얼마나 들어있는지
- 배열 **인덱스**, 특정 데이터가 배열의 어디에 있는지 알려주는 수

##### 1.2.1 자료 구조 연산
- 배열 같은 자료 구조 성능 알기 위해 코드가 자료구 조와 일반적으로 어떻게 상호작용하는 지 분석
- 대부분의 자료 구조 4가지 기본 방법 사용하며 이를 **연산**이라 부름
    - 읽기, 자료 구조 내 특정 위치를 찾아보는 것으로 배열 내 특정 인덱스 값을 찾아본느 것 뜻함
    - 검색, 자료 구조내 특정 값을 차는 것, 배열에선 특정 값이 배열에 있는지 있다면 어떤 인덱스에 있는지 알아보는 것 뜻함
    - 삽입, 자료 구조에 새로운 값을 추가하는 것, 배열 내 슬롯을 더 만들어 새 값 추가하는 것 뜻함
    - 삭제, 자료 구조에서 값을 제거, 배열에선 배열의 값 중 하나 제거하는 것 뜻 함

#### 1.3. 속도 측정
- 연산의 속도 측정 방법
- 빠른가를 측정할 땐 순수하게 **시간**관점에서 연산이 얼마나 빠른가가 아닌 얼마나 많은 **단계**가 필요한지 논해야 함
- 코드 속도를 단계로 측정하는 이유는 시간은 연산을 실행하는 하드웨어 따라 항상 바뀌므로 시간을 기준으로 측정하면 신뢰할 수 없다
- 따라서 연산 속도 측정 시 얼마나 많은 **계산 단계**가 필요한가를 따져야함
- 연산 속도 측정은 연산의 **시간 복잡도** 측정으로 알려지며 **속도, 시간 복잡도, 효율성, 성능** 용어 같은 의미로 모두 연산에 걸리는 단계 수 의미

#### 1.4 읽기
- 배열 내 특정 인덱스 어떤 값이 있는지 찾아보는 것
- 컴퓨터는 딱 한 단계로 배열에서 읽는데 배열 내 특정 인덱스 에 한 번에 접근 가능하기에
- 컴퓨터는 딱 한 단계로 배열에서 읽을 수 있는 이유?
    - 컴퓨터 메모리는 셀로 구성된 거대한 컬렉션
    - 프로그램에서 배열 선언하면 컴퓨터는 프로그램 쓸 수 있는 연속된 빈 셀들으 집합을 할당
    - 컴퓨터 메모리 내 각 셀엔 특정 주소 존재, 각 셀의 메모리 주소는 앞 셀의 주소에서 1씩 증가
    - 컴퓨터가 배열 특정 인덱스에 있는 값을 읽을 때 한 번의 단계로 갈 수 있는 이유 1. 컴퓨터 모든 **메모리 주소** 한 번에 갈 수 있음
    2. 컴퓨터 배열 할당 시 어떤 메모리 주소에서 **시작하는지도** 기록해둬 배열의 첫 번째 원소 찾으라 요청하면 적절한 메모리 주소로 바로 가서 찾음

- 컴퓨터는 어떤 메모리 주소든 한 번에 접근해 어떤 인덱스든 읽을 수 있으므로 배열 읽기는 매우 효율적 연산

#### 1.5 검색
- 배열 **검색** 배열에 특정 값이 있는지 알아본 후 있다면 어떤 인덱스에 있는지 찾음
- 읽기는 컴퓨터에 인덱스 제공 후 그 인덱스 들어있는 값 반환하라 요청
- 검색은 컴퓨터 값 제공 후 그 값이 들어있는 인덱스 반환하라 요청
- 검색은 특정 값으로 바로 갈 수 없으니 오래 걸림
- 알고리즘이 중요한 까닭은 검색 연산은 컴퓨터가 한 번에 한 셀씩 확인하는 방법인 **선형 검색**을 사용


#### 1.6 삽입
- 배열에 데이터 삽입하는 연산은 어디에 데이터를 삽입하는 가에 따라 효율성 다름
- 배열 할당 시 항상 배열의 크기를 기록하는 특징에 기인
1> 배열 끝에 데이터 삽입 시 - 딱 한단계만 필요
    - 컴퓨터는 새 값을 삽입할 메모리 주소 계산 할 수 있으며 한 단계면 됌
2> 배열 중간에 데이터 삽입 시 
    - 삽입할 공간 만들기 위해 많은 데이터 조각 **이동**시켜야 함
    - 데이터를 오른쪽으로 몇번 옮기는 단계 + 실제 새 값을 삽입하는 1단계 
3> 배열 맨 처음 삽입 시 - N+1단계 필요
    - **모든** 값을 한 셀 씩 오른쪽으로 옮겨야 함

#### 1.7 삭제
- 배열 삭제, 특정 인덱스 값 제거 과정
- 삭제 시엔 실제 삭제 단계와 나머지 단꼐는 빈 공간을 메꾸는 데이터 이동 단계
- 첫 번째 원소 삭제 시 모든 원소 왼쪽으로 이동시켜 빈공간 채워야 함
    - 따라서 원소 N개 포함한 배열에 삭제 필요한 최대 단계 N 단계

>- 배열 자료 구조의 시간 복잡도 분석
>- 앞으로 서로 다른 자료 구조 어떻게 서로 다른 효율성 내는지 살펴봄

#### 1.8 집합 : 단 하나의 규칙으로 효율성 달라짐
-**집합**? 중복 값 허용하지 안흔 자료구조
- 실제 집합 종류 다양하지만 여기선 배열 기반 집합 다룸
    - **배열 기반 집합**? 값들의 단순 리스트로 배열과 비슷하나 유일한 차이는 집합은 중복 값의 삽입을 허용하지 않는 다는 것
- 집합은 중복 데이터 없어야 할 때 유용
- 즉, 배열 기반 집합이란 중복 금지 제약 하나 더 추가 된 배열로 이 제약으로 인해 네 주요 연산 중 하나에서 **집합의 효율성 크게 달라짐**

##### 1.8.1 배열 기반 집합으로 읽기, 검색, 삽입, 삭제 연산 분석
- 집합 읽기는 배열 읽기와 동일 > 한 단계 소유
- 집합 검색도 배열 검색과 차이 없음 > 최대 N단계 걸림
- 삭제도 동일 > 최대 N 단계
- 삽입 배열과 집합이 다름
    - 맨 끝에 삽입 시, 배열에서 컴퓨턴 1단계로 값을 끝에 삽입
    - 집합에선 이 값이 집합에 들어있는지 결정해야 함(중복 데이터 막는 게 집합  역할)
    - 모든 삽입 시 **검색 우선** 
        - 집합 끝에 삽입 시 원소 N개에 최대 N+1단계 필요 (값이 집합에 없음 확인 N단계 검색, 이어서 삽입에 1단계)
        - 집합 맨 압 삽입 시 최악은 셀 N개 검색해 그 값을 포함하지 않음 확인 후 N단계로 모든 테이블 오른쪽 옮겨 마지막 단계에 새 값 삽입하여
        2N+1 단계
        <-> 배열은 N+1단계 걸리는 것과 대조 됌

- 어플리케이션의 요구사항 분석 후 어떤 자료 구조가 적합한지 결정이 중요

#### 1.9 마무리
- 자료구조 성능 측정은 연산에 필요한 단계 수를 구하는 것이 핵심
- 같은 방법으로 서로 경쟁하는 알고리즘 비교해 코드가 최고의 속도와 성능
#### 1.10 연습 문제
- 1.10.1.a > 1단계
- 1.10.1.b > N단계
- 1.10.1.c > N+1단계
- 1.10.1.d > 1단계
- 1.10.1.e > N단계
- 1.10.1.f > 1단계

- 1.10.2.a > 1단계
- 1.10.2.b > N단계
- 1.10.2.c > 2N+1단계
- 1.10.2.d > N+1단계
- 1.10.2.e > N단계
- 1.10.2.f > 1단계

- 1.10.3 > N단계







