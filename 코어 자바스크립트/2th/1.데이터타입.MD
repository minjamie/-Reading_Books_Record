- 데이터 타입
    1. 데이터 타입을 구분하는 이유?
    - 데이터 타입을 구분하는 가장 큰 이유는 `메모리 공간 확보`
    1. 값 저장할 때 확보해야 할 메모리 공간  크기를 결정 
    2. 값 참조할 때 한 번에 읽어들어야 할 메모리 공간의 크기를 결정
    3. 메모리리에서 읽어들인 2진수를 어떻게 해석할지 결정
    1. 데이터 타입의 종류?
    - 자바스크립트의 데이터 타입은 크게 2가지로 `기본형(원시형)과 참조형`이있다. 
    기본형에는 숫자, 문자열, 불리언, undefiend, ES6엔 심볼이 추가
    참조형에는 객체, 배열, 함수, 날짜, 정규표현식과 ES6엔 Map,Set,WeakMap,WeakSet 추가
    1. 기본형과 참조형의 구분?
    - **기본형과 참조형 모두 복제**를하지만
     `기본형`은 **값이 담긴 주솟값을 바로 복제**하는 반면 `참조형`은 **값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제**한다는 점이 다르다.
    또한 기본형은 `불변성`을 띄고 참조형은 `가변성`을 띄운다.
    1. 불변성과 가변성?
    - 불변성을 이해하기 위해선 1> 메모리와 데이터에 대한 지식과 2> 식별자와 변수의 개념을 구분해야함
        - 4_1> 데이터 타입에 관한 배경지식
            - 비트
                - 0또는 1로 표현할 수 있는 **하나의 메모리 조각이다.**
                메모리는 매우 많은 비트들로 구성되고 각 비트는 고유한 **식별자**를 통해 위치를 확인할 수 있다.
                - 비트의 한계? 
                0과 1로만 표현할 수 있는 비트 단위로 위치를 확인하는 건 비효율적(검색 시간이 오래걸리며 표현할 수 있는 값도 한정)
                - 바이트의 탄생 배경?
                    
                    **매우 많은 비트를 하나의 단위로 묶어** 여긴다면 검색 시간은 줄이고 표현할 수 있는 데이터 갯수를 늘지만 다만 낭비되는 비트가 생기기도 한다.
                    자주 사용하지 않을 데이터를 표현하기 위해 표현 가능한 개수에 어느정도 제약이 따르더라도 크게 문제 되지 않을 **적정 공간을 묶은 결과 바이트**라는 단위가 생겼다.
                    
                - 바이트? 
                1바이트는 8개의 비트로 구성되어있고 1비트마다 0또는 1의 두 가지 값을 표현할 수 있으므로 1바이트는 2의 8승, 256개의 값을  표현할 수 있다.
            - 정적 타입 언어와 자바스크립트(동적 타입 언어)
                - C/C++, 자바 등의 정적 타입 언어는 메모리의 낭비를 최소화하기 위해 데이터 별로 할당할 메모리 영역을 2, 4바이트 등으로 나누어 정했다.
                - 메모리 용량이 월등히 커진 상황에서 등장한 자바스크립트는 상대적으로 메모리 관리에 압박에 자유로워져 메모리 공간을 더 넉넉하게 할당
    1. 메모리 주솟값?
    - **각 비트는 고유한 식별자**를 지니며 바이트 역시 시작하는 비트의 식별자로 위치를 파악한다.
    모든 데이터는 바이트 단위의 식별자, 정확하게는 **메모리 주솟값**을 통해 서로 구분하고 연결할 수 있다.
    1. 변수
    - 변수란 **변할 수 있는 데이터(숫자, 문자열, 객체, 배열)**를 의미한다.
    **변경 가능한 데이터가 담길 수 있는 공간 또는 그릇과** 같은 역할
    1. 식별자
    - 식별자는 **어떤 데이터를 식별하는 데 사용하는 변수명**을 의미한다.
    1. 변수 선언
    - 변할 수 있는 데이터를 만들고 그 데이터의 식별자를 정한다.
    1. 변수 선언에 대한 메모리 영역의 변화
    EX> `var a`
    1> 컴퓨터는 메모리에 비어있는 공간 하나를 확보한다
    2> 이 공간의 이름, 식별자를 a라고 지정한다.
    사용자가 a에 접근하고자 할 때 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환한다.
    2. 데이터 할당 
    - 변수에 데이터를 할당하는 과정
    1. 데이터 할당에 대한 메모리 영역 변화
    EX> `var a = 'abc'` 
    a라는 식별자를 가진 주소를 검색해서 그곳에 문자열 ‘abc’을 할당한다.
    그러나 해당 위치에 문자열 ‘abc’를 직접 저장하지 X 
    
    1. 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보  2. 그 주소를 변수 영역에 저장
    ’변수 영역’과 ‘데이터 영역’을 구분해야한다.
    
    3> ‘데이터 영역’의 빈 공간에 문자열 'abc’를 저장한다
    4> 변수 영역에서 a라는 식별자를 검색한다.
    5> 앞서 저장한 문자열의 주소를 변수영역이 확보한 빈 공간에 대입한다.
    2. 변수 영역에 값을 직접 대입하지 않고 한 단계 더 거치는 이유?
    - 1> 데이터 변환을 자유롭게 할 수 있게 함과 동시에 2> 메모리를 더 효율적으로 관리하기 위해서(중복된 데이터에 대한 처리 효율 높아짐)
    
    EX_1> 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 다시 저장하기 위해선 
    ’확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업'이 선행되야하며 컴퓨터가 처리해야할 연산이 많아진다.
    EX_2> 문자열 ‘abc’ 마지막에 ‘def’추가, ‘c’제거 한다면? 
    기존 문자열에 어떤 변환을 가하든 상관없이 무조건 **새로** 만들어 **별도의 메모리 공간에 저장하고 그 주소를 변수 공간에 연결한다.**
    1. 불변값과 상수
    변수와 상수를 구분하는 성질, `변경 가능성`
    바꿀 수 있으면 변수, 바꿀 수 없으면 상수이다.
    - 변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다. 한 번 데이터 할당이 이뤄지면 변수 공간에 다른 데이터를 재할당 할 수 있는지 여부가 관건
    - 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.
    - 변경은 새로 만든 동작을 통해서만 이뤄지는데 이것이 바로 불변값의 성질이다. 
    한 번 만들어진 값은 가비지 컬렉팅 당하지 않는 한 영원히 변하지 않는다.
    1. 가변값 
    기본형 데이터는 모두 불변값이고 참조형 데이터는 가변값인 경우가 많지만 설정에 따라 변경 불가능 한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다.
    EX> `var obj = {a:1, b: bbb}`
    데이터 영역에 저장된 값은 여전히 메모리 공간을 그대로 활용하며 모두 불변값이지만 변수에 다른 값을 대입할 수 있기 때문에 불변하지 않는, 가변값이라 한다.
    2. 참조형 데이터의 할당/재할당
    기본형 데이터와의 차이는 ‘객체의 변수 (프로퍼티) 영역'이 별도로 존재한다는 점이다.
    객체의 프로퍼티 값이 변경한다는 건 새로운 객체가 만들어 진 것이 아닌 기존의 객체 내부의 값만 바뀐 것이다.
    3. 중첩된 참조형 데이터의(중첩 객체) 프로퍼티 할당
    어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 참조 카운트라 한다.
    참조 카운트가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 된다.
    가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화상태에 임박할 때 마다 자동으로 수거 대상들을 수거한다.
    4. 변수 복사 비교
    - 변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일하다.
    단, 데이터 할당 과정에서 차이가 있으므로 변수 복사 이후 동작에 차이가 발생한다.
    1. 변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티를 변경했을 때 
    기본형 데이터를 복사한 변수b의 값을 바꾸면 변수 a와 b는 다른 주소를 바라보게 되나
    참조형 데이터를 복사한 변수obj2의 프로퍼티값을 바꾸면 변수 obj1과 obj2는 여전히 같은 객체를 바라본다.
    - 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조혀은 한 단계를 더 거치게된다는 차이가 있다.
    1. 변수 복사 이후 값 변경 결과 비교 - 객체 자체를 변경했을 때 
    참조형 데이터가 ‘가변값’라 설명할 때 ‘가변'은 참조형 데이터 자체를 변경할 경우가 아닌 내부 프로퍼티를 변경할 경우에만 성립
    2. 변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티를 변경했을 때 
    기본형 데이터를 복사한 변수b의 값을 바꾸면 변수 a와 b는 다른 주소를 바라보게 되나
    참조형 데이터를 복사한 변수obj2의 프로퍼티값을 바꾸면 변수 obj1과 obj2는 여전히 같은 객체를 바라본다.
    
    ## 5. 불변 객체
    
    1.  불변 객체 불변 객체를 만드는 간단한 방법
    - 값으로 전달 받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야하는 경우 불변객체가 필요하다
    
    1. **얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고 깊은 복사는 내부의 모든 값 하나하나 찾아서 전부 복사하는 방법이다.**
    - 얕은 복사를 하면 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다.
    해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소를 가리킨다.
    **즉 사본을 바꾸면 원본도 바뀌고 원본을 바꾸면 사본도 바뀐다.**
    - 1> 한 단 계 더 들어간 변수의 내부 프로퍼티들은 **기존 데이터를 그대로 참조**한다. 
    이런 현상이 발생하지 않게 하려면 변수의 내부 프로퍼티에 대해서도 불변객체로 만들 필요가 있다.
    - 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때 객체의 프로퍼티 중 그 값이 **기본형 테이터일 경우 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티를 복사해야한다.**
    - 2> 객체를 JSON 문법으로 표현된 문자열로 전환→ 다시 JSON 객체로 바꾸는 방식,
    
    ## 6. undefined와 null
    
    - 자바스크립트에서 ‘없음’을 나타내는 값 2가지 - undefined와 null
    - 두 값의 의미는 미세하게 다르고 사용하는 목적도 다르다.
    
    1. undefined
    - 자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 예상되는 상황임에도 그렇게 하지 않았을 때 undefined를 반환
    다음 세가지 경우에 해당
        - 값을 대입하지 않은 변수, 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근 시
        - 객체 내부의 존재하지 않는 프로퍼티에 접근할 시
        - return 문이 없거나 호출되지 않는 함수의 실행 결과
    1. undefined와 배열
    - ‘비어있는 요소'와 ‘undefiend를 할당한 요소'는 출력 결과부터 다르다. ‘비어있는 요소’는 순회와 관련된 배열 메서드들의 순회 대상에서 제외된다.
    - 값이 지정되지 않은 인덱스는 아직 존재하지 않는 프로퍼티에 지나지 않는다.
    - 값으로서 어딘가에 할당되는 undefiend은 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타낸다.
    undefined는 오직 값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값으로서만 존재할 수 있다.
    1. null
    - 비어있음을 명시적으로 나타내고 싶을 땐 undefined가 아닌 null을 쓴다.
    - typeof null은 object라는 것 주의, 자바스크립트 자체 버그