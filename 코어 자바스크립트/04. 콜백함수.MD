# 04 콜백함수

---

## 01 콜백함수란

1.  콜백함수
    **콜백 함수는 다른 코드의 인자로 넘겨주는 함수, 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행**
    \*\*콜백함수는 제어권과 관련이 깊은데 다른 코드 (함수 또는 메서드)에 인자로 넘겨줌으로서 제어권도 함께 위임한 함수

        콜백 함수를 위임 받은 코드는 자체적인 내부 로직에 의해 콜백함수를 적절한 시점에 실행

        callback 의미는 ’되돌아 호출해달라’는 명령어
        EX> 어떤 함수 X를 호출하면 특정조건일 때 함수 Y를 실행해서 알려달라는 요청을 함께 보내는 것**

---

## 02 제어권

2. 호출시점
   **콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 시점에 대한 제어권을 가진다**
   cbFunc()의 호출 주체는 사용자이며 제어권도 사용자에게 있지만 setInterval(cbFunc,300)의 호출 주체와 제어권을 setInterval에 넘겨준다.

3. 인자
   **콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출 할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가진다.**
   map 메서드에 정의도니 규칙에 콜백 함수의 인자로 넘어올 값들 및 순서도 포함돼 있다.
   콜백함수를 사용하는 주체가 사용자가 아닌 map 메서드이므로 map 메서드가 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 건지는 map 메서드에 달려있다.

4. this
   \*\*콜백 함수도 함수이기에 기본적으로 this가 전역 객체를 참조하지만 제어권을 넘겨받을 코드에서 콜백함수에 별도로 this가 될 대상을 지정한 경우엔 그 대상을 참조한다.

이유 -** this에 다른 값이 담기는 이유는 제어권을 넘겨받을 코드에서 call/apply 메서드의 **첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 명시적을 바인딩\*\*하기 때문

---

## 03 콜백함수는 함수다

5. 콜백함수가 함수인 이유
   **콜백 함수로 어떤 객체의 메서드를 전달하더라고 그 메서드는 메서드가 아닌 함수로 호출된다.**

그러니깐 **어떤 함수의 인자에 객체의 메서드를 전달하더라고 이는 결국 메서드가 아닌 함수 일 뿐이다**.

---

## 04 콜백 함수의 내부의 this에 다른 값 바인딩하기

6. 콜백 함수 내부에 this가 객체를 바라보게 하는 방법
   6_1. 별도의 인자로 this를 받는 함수의 경우
   원하는 값을 넘겨준다.

6_2. 그렇지 않은 경우
this의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 바꿀 수 없다.
\*\*this를 다른 변수에 담아 콜백함수로 활용할 함수에는 this 대신 그 변수를 사용하게 되고 이를 클로저로 만드는 방식이 많이 쓰였다.

6_3. bind 메서드를 이용하는 방법\*\*

---

## 05 콜백 지옥과 비동기 제어

7. 콜백 지옥과 비동기 제어
   **콜백 지옥은 콜백함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들정도로 깊어지는 현상**

언제 쓰이느지? - 이벤트 처리나 서버 통신과 같이 비동기적인 작업을 수행하기 위해 콜백 지옥의 형태가 자주 등장
문제? - 가독성 떨어지고 코드 수정도 어렵다

8. 비동기와 동기
   1> **비동기 동기는 반대말인데 동기적인 코드는 현재 실행 중인 코드가 완료되어야 다음 코드를 실행하는 방식
   2> 비동기 코드는 현재 실행중인 코드의 완료와 무관하게 즉시 다음 코드로 넘어가는 방식**

CPU 계산에 의해 즉시 처리가 가능한 대부분의 코드는 동기적 코드
반면 1> 사용자의 요청에 의해 특정 시간이 경과되기 전까지 어떤 함수의 실행을 보류(setTimeout)한다거나 2>사용자의 직접적인 개입이 있을 때 비로소 함수를 실행하도록 한다거나(addEventListenr) 3> 웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 비로소 함수를 실행하도록 대기하는 등(XHLHttpRequest), **별도의 요청, 실행 대기 , 보류 등과 관련되 코드는 비동기 코드**이다. 3. 콜백 함수를 해결하는 가장

9. 간단한 방법 - 익명 함수를 모두 기명함수로 전환하는 것
   가독성 높일 뿐만 아니라 함수 선언과 호출만 구분할 수 있다면 위에서 아래로 순서대로 읽어나가는 데 어려움이 없다.
   단, 변수를 최상단으로 호이스팅하여 외부에 노출되지만 전체를 즉시 실행 함수로 감싸면 해결할 수 있다
   문제? 일회성 함수를 전 변수에 할당하는 것 번거롭고 , 코드명 일일이 따라다는면 헷갈릴 여지도 생긴다.

10. 비동적인 일련의 작업을 동기적으로 혹은 동기적으로 보이게끔 처리해주는 장치
    ES6 - Promise, Generator 도입
    ES2017 - async/await 도입

11. Promise
    new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출 할 때 바로실행되지만
    내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지 다음 , (then) 또는 오류 (catch) 구문으로 넘어가지 않ㄷ는다

**비동기 작업이 완료 될 때 비로소 resolve 또는 reject를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능**하다.

12. Generator

- 붙은 함수가 Generator함수인데 Generator를 실행하면 Iterator가 반환되고 Iterator는 next라는 메서드를 가진다. next를 호출하면 Generator 함수 내부에 가장 먼저 등장한 yield 함수의 실행을 멈추고 다시 next 메서드를 호출하면 앞서 멈췄던 부분 부터 시작해서 그 다음 등장하는 yield에서 함수의 실행을 멈춘다.

**비동기 작업이 완료되는 시점마다 next 메서드를 호출해주면 Generator 함수 내부의 소스가 위에서 아래로 순차적으로 진행**

13. 비동기 작업의 동기적 표현

- Promise + async/await
  가독성이 뛰어나면서 작성법도 간단한 새로운 기능 async/await 등장,
  **비동기 작업을 수행하고자 하는 함수 앞에 async를 표기 , 함수 내부에 실질적인 비동기 작업이 필요한 위치마다 await를 표기함**으로서 \*\*뒤의 내용을 자동으로 Promise로 전환하고 해당 내용이 resolve 된 이후에야 다음으로 진행
  즉 Promise의 thne과 흡사한 효과\*\*
