# 06 프로토타입

    - 자바스크립트는 프로토타입 기반 언어이다.
    - 프로토타입 기반 언어에선 어떤 객체를 원형으로 삼고 이를 복제 함수으로써 상속과 비슷한 효과를 얻는다.

    ---

### **01. 프로토 타입 개념 이해**

```jsx
var instance = new Constructor();
```

    - 어떤 생성자 함수를 new 연산자와 함께 호출하면
    - Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성됩니다.
    - 이때 Instance에서 \***\*_proto_\*\***라는 프로퍼티가 자동으로 부여되는데
    - 이 프로퍼티는 Constructordml prototype이라는 프로퍼티를 참조합니다.


    1. prototype이라는 프로퍼티와 \***\*_proto_\*\***라는 프로퍼티의 관계가 프토토타입의 개념의 핵심이다.
      prototype은 객체로 이를 참조하는 \***\*_proto_\*\*** 역시 객체이다.
      prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장한다. 그러면 인스턴스에서도 숨겨진 프로퍼티인 \***\*_proto_\*\*** 를 통해 이 메서드들에 접근할 수 있게 된다.

    2. ES5 명세엔 \***\*_proto_\*\*** 가 아닌 [[prototype]]이라는 명칭으로 정의 \***\*_proto_\*\*** 프로퍼티는 브라우저들이 [[prototype]]을 구현한 대상에 지나지 않는다.
      실무에선 가급적 \***\*_proto_\*\***을 사용하지 않고 대신 Object.gertPrototypeOf()/Object.create()등을 이용하는 것을 권장한다.

    ---

    3.  Person.prototype

    ```jsx
    var Person = function (name) {
      this._name = name;
    };
    Person.prototype.getName = function () {
      return this.__name2;
    };
    var minjae = new Person("minajae");
    minjae._proto_.getName(); //undefined
    Person.prototype === minjae.__proto__; //true
    ```



    - Person의 인스턴스는 \***\*_proto_\*\*** 프로퍼티를 통해 getName을 호출할 수 있다.
      instance의 \***\*_proto_\*\***가 Constructor의 prototype 프로퍼티를 참조하므로 결국 이 둘은 같은 객체를 바라본다
    - \***\*_proto_\*\***는 생략가능한 프로퍼티이다.

    4. 프로토타입 개념 상세화
       1> 자바스크립트는 함수에 자동으로 객체인 prototype 프로퍼티를 생성해 놓는다.
       2> 해당 함수를 생성자 함수로서 사용할 경우, 즉 new 연산자와 함께 호출할 경우
       3> 그로 부터 생성된 인스턴스에는 숨겨진 프로퍼티인 \***\*_proto_\*\***가 자동으로 생성되며
       4> 이 프로퍼티는 생성자 함수의 프로퍼티를 참조한다.
       5>\***\*_proto_\*\***프로퍼티는 생략가능하도로 구현되어있다.
       **따라서 생성자함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게된다.**

    ***

    5. 배열 리터럴과 Array의 관계
       Array의 prototype 프로퍼티 내부에 있지 않은 from, isArray 등의 메서드들은 인스턴스가 직접 호출할 수 없는데 이들은 Array 생성자 함수에서 직접 접근해야 실행이 가능하다.
    6. constructor 프로퍼티
       생성자 함수의 프로퍼티인 prototype 객체 내부에는 constructor라는 프로퍼티가 있다.
       인스턴스의 \***\*_proto_\*\***객체 내부에도 마찬가지이다.
       이는 단어 그대로 원래의 생성자 함수(자기 자신)을 참조한다. 인스턴스로부터 그 원형이 무엇인지 알수 있는 수단으로 보통 쓰인다.

    ***

    ## 02. 프로토타입 체인

    7. 메서드 오버라이드
       prototype 객체를 참조하는 \***\*_proto_\*\***를 생략하면 인스턴스는 prototype에 정의된 프로퍼티나 메서드를 마치 자신의 것처럼 사용할 수 있다.
       그럼 만약 인스턴스가 동일한 이름의 프로퍼티나 메서드를 가지고 있다면?
       **오버라이드란 메서드 위에 메서드를 덮어씌우는 표현으로 원본을 제거하고 다른 대상으로 교체하는 것이 아니라 원본이 그대로 있는 상태에서 다른 대상을 그위에 얹는 이미지이다.
       자바스크립트 엔진은 메서드를 찾을 때 1> 가장 가까운 대상인 자신의 프로퍼티를 검색하고 2> 없으면 다음으로 가까운 대상인** \***\*_proto_\*\***를 검색하는 순서로 이뤄진다.

    일반적으로 메서드가 오버라이드 된 경우 자신으로부터 가장 가까운 메서드에만 접근할 수 있지만 그 다음으로 가까운 \***\*_proto_\*\***의 메서드도 우회회적인 방법을 통해서 접근이 가능하다.
    - **오버로딩과 오버라이드**

    메서드 오버로딩(overloading)은 상속과는 관계 없이 동일 Class 내에 동일한 Method 이름으로 parameter 등을 추가하여 사용하는 것이다.

    자바스크립트는 문법적을 오버로딩을 제공하지 않지만  대신 생성자 함수를 이용해 일반 객체지향 언어의 클래스를 흉내 내듯이 오버로딩 또한 흉내낼 수 있습니다.

    자바스크립트에서는 매개변수 정보를 담고 있는 arguments를 이용해 오버로딩을 흉내낼 수 있습니다.

    반면 메서드 오버라이드(override)는 자식 클래스에서 부모 클래스의 기능(method)을 재정의할 때 사용하는 기능으로 다음과 같은 경우에 주로 사용합니다.

    - 부모 클래스의 기능을 사용하지 않고 자식 클래스에서 구현한 기능을 사용하고 싶은 경우
    - 부모 클래스의 기능을 자식 클래스에서 확장하고 싶은 경우

    8. 프로토타입 체이닝 \**어떤 데이터의 \_\_*proto**_ 프로퍼티 내부에서 다시 _**proto\*\_\_프로퍼티가 연쇄적으로 이어진 것을 프로토타입 체인이라하고 이를 따라 검색하는 것을 프로토타입 체이닝이라한다.

    이는 오버라이드와 동일한 맥락으로 어떤 메서드를 호출하면 자바스크립트 엔진은 데이터 자신의 프로퍼티를 검색해서 원하는 메서드가 있으면 실행하고 없으면 **_proto_**를 검색해서 실행하는 식으로 진행된다.** 3. 객체 전용 메서드의 예외사항
    `prototype`은 객체이므로 `Object.prototype`은 항상 최상단에 위치해 있다.
    이로인해 생길 수 있는 문제점은 `Object.prototype`에 특정 메소드를 정의하면, 모든 타입*(함수,배열, 원시 데티어 등등)*에서 사용될 수 있다는 것이다.
    따라서, **객체 타입에만\*\* 적용하고 싶은 메소드가 있다면,`Object`의 static메소드로 정의해야한다.
    이를 피하기 위해 Object.create를 이용하면되는데 Object.create(null)은 `__proto__`가 없는 객체를 생성할 수 있다.

    - 이 방식은 `__proto__`가 없는 객체를 생성한다.
    - Object.prototype메서드에 접근할 수 없다.
    - 내장 메서드 및 프로퍼티가 제거되어 객체 자체 무게가 가벼워져 성능상 이점이 있다.

    9. 다중 프로토타입 체인
    - 프로토타입 체인을 2단계 이상으로 연결하고 싶을땐 **proto**가 가리키는 대상, 즉 생성자 함수의 prototype이 연결하고자 하는 상위 생성자 함수의 인스턴스를 바라보게끔 해주면 된다.
