#### 1장에서 다루는 것
- 자바스크림트가 데이터 처리하는 과정
- 기본형, 참조형 서로 다르게 동작하는 이유 이해 및 이를 활용
- 데이터 타입 관련된 중요 개념 몇가지 살펴보기

---
#### 1. 데이터 타입의 종류
>1. 데이터 타입 종류
- 크게 기본형(원시형)과 참조형
- 기본형에는 숫자, 문자열, 불리언, undefiend, ES6엔 심볼이 추가
- 참조형에는 객체, 배열, 함수, 날짜, 정규표현식과 ES6엔 Map,Set,WeakMap,WeakSet등 객체 하위 분류 속하여 추가

>2. 기본형과 참조형의 구분?
- 기본형은 값이 담긴 주솟값을 바로 복제하는 반면 
- 참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제
- 또한 기본형은 불변성을 띄고 참조형은 가변성을 띄움

>3. 불변성과 가변성?
- 불변성을 이해하기 위해선 1> 메모리와 데이터에 대한 지식과 2> 식별자와 변수의 개념을 구분해야함

---

#### 2. 데이터 타입 배경지식
>1. 메모리와 데이터
- 비트는 0또는 1로 표현할 수 있는 하나의 메모리 조각으로 메모리는 매우 많은 비트들로 구성되고 각 비트는 고유한 식별자를 통해 위치를 확인
- 0과 1로만 표현할 수 있는 비트 단위로 위치를 확인하는 건 비효율적(검색 시간이 오래걸리며 표현할 수 있는 값도 한정)
- 자주 사용하지 않을 데이터를 표현하기 위해 표현 가능한 개수에 어느정도 제약이 따르더라도 크게 문제 되지 않을 적정 공간을 묶은 결과 바이트 단위가 생김
- 1바이트는 8개의 비트로 구성되어있고 1비트마다 0또는 1의 두 가지 값을 표현할 수 있으므로 1바이트는 2의 8승, 256개의 값을  표현

>정적 타입 언어와 동적 타입 언어
- C/C++, 자바 등의 정적 타입 언어는 메모리의 낭비를 최소화하기 위해 데이터 별로 할당할 메모리 영역을 2, 4바이트 등으로 나누어 정함
- 메모리 용량이 월등히 커진 상황에서 등장한 자바스크립트는 상대적으로 메모리 관리에 압박에 자유로워져 메모리 공간을 더 넉넉하게 할당

- 각 비트는 고유한 식별자를 지니며 바이트 역시 시작하는 비트의 식별자로 위치를 파악
- 모든 데이터는 바이트 단위의 식별자, 정확하게는 메모리 주솟값을 통해 서로 구분하고 연결

>2. 식별자와 변수
- 변수란 변할 수 있는 데이터(숫자, 문자열, 객체, 배열)를 의미로 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇 역할
- 식별자는 어떤 데이터를 식별하는 데 사용하는 이름, 변수명을 의미

---

#### 3. 변수 선언과 데이터 할당
1. 변수 선언
- 변할 수 있는 데이터를 만들고 그 데이터의 식별자를 정함
- 변수 선언에 대한 메모리 영역의 변화

>EX> 변할 수 있는 데이터를 만들고 그 데이터의 식별자 a 정함
```js 
var a
```
1> 컴퓨터는 메모리에 비어있는 공간 하나를 확보
2> 이 공간의 이름, 식별자를 a라고 지정, 여기까지 변수 선언 과정
3> 사용자가 a에 접근하고자 할 때 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환

2. 데이터 할당
- 변수에 데이터를 할당하는 과정

>EX> a라는 식별자를 가진 주소를 검색해서 그곳에 문자열 ‘abc’을 할당하나 해당 위치에 문자열 ‘abc’를 직접 저장하지 않음 
```js
var a = 'abc'
``` 
*) 데이터 성질에 따라 설명을 위해 ’변수 영역’과 ‘데이터 영역’을 구분
1> 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보(=변수 영역 저장 위한 빈 공간 확보)
2> 그 주소를 변수 영역에 저장 (= 확보한 공간 식별자 a 지정)
3> ‘데이터 영역’의 빈 공간에 문자열 'abc’를 저장
4> 변수 영역에서 a라는 식별자를 검색
5> 앞서 저장한 문자열의 주소를 변수영역이 확보한 빈 공간에 대입

변수 영역에 값을 직접 대입하지 않고 한 단계 더 거치는 이유?
**1> 데이터 변환을 자유롭게 할 수 있게 함
2> 메모리를 더 효율적으로 관리(중복된 데이터에 대한 처리 효율 높아짐)
**
즉, 효율적으로 데이터 변환 처리 위해 변수와 데이터 별도 공간 나누어 저장하는 것이 메모리 관리 최적

EX_1> 미리 확보한 공간 내에서만 데이터 변환을 하면 변환한 데이터를 다시 저장하기 위해 ’확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업' 선행되어 컴퓨터 처리해야할 연산 많아짐
EX_2> 문자열 ‘abc’ 마지막에 ‘def’추가 또는 ‘c’ 제거 시 
기존 문자열에 어떤 변환을 가하든 상관없이 무조건 **새로** 만들어 **별도의 메모리 공간에 저장 및 그 주소를 변수 공간에 연결**

---

#### 4. 기본형 데이터와 참조형 데이터
1. 변수와 상수를 구분하는 성질 ?

>`변경 가능성`으로 바꿀 수 있으면 변수, 바꿀 수 없으면 상수

*주의) 불변값과 상수 구분 필요
>- 변수와 상수를 구분 짓는 변경 가능성의 대상 **변수 영역 메모리**로 한 번 데이터 할당이 이뤄지면 변수 공간에 다른 데이터를 재할당 할 수 있는지 여부가 관건
- 반면 불변성 여부 구분 시 변경 가능성의 대상은 **데이터 영역 메모리**이다

2. 불변성 개념
>- 기본형 데이터는 모두 불변값으로 한 번 만든 값은 바꿀 수 없고 다른 값으로 변경할 수 없음
- **변경은 새로 만드는 동작을 통해서 이루어지며** 한 번 만들어진 값은 가비지 컬렉팅 당하지 않은 한 영원히 변하지 않음 

3. 가변 값
- 기본형 데이터는 모두 불변값이고 참조형 데이터는 가변값인 경우가 많지만 설정에 따라 변경 불가능 한 경우도 있고, 아예 불변값으로 활용하는 방안도 있음 

>EX> 참조형 데이터 변수에 할당하는 고정
```js 
var obj = {a:1, b: bbb}
```
- 데이터 영역에 저장된 값은 여전히 메모리 공간을 그대로 활용하며 모두 불변값이지만 변수에 다른 값을 대입할 수 있기 때문에 불변하지 않는, 가변값이라 함
- 기본형 데이터 차이는 **객체 변수(프로퍼티) 영역 별도 존재**하여 객체가 별도로 할애한 영역 변수 영역이며 데이터 영역은 기존 메모리 공간 활용
- 데이터 영역 저장된 값 모두 불변이나 변수에 다른 값을 얼마든지 대입할 수 있으므로 참조형 데이터는 불변하지 않는, 즉 가변값임


>EX_1> 참조형 데이터의 프로퍼티 재할당
```js 
var obj = {a:1, b: bbb}
obj.a = 2;
```
- 객체의 프로퍼티 값이 변경한다는 건 새로운 객체가 만들어 진 것이 아닌 기존의 객체 내부의 값만 바뀐 것

>EX_2> 참조형 데이터(중첩 객체)의 참조형 데이터 할당 및 재할당, 
```js 
var obj = {x:3, arr: [3,4,5]}
obj.arr ='str'
```
- 객체 변수 영역 별도 존재하듯, 배열 변수 영역 별도로 존재하여 해당 영역에 데이터 영역 주소값 저장
- 재 할당시 배열은 더이상 주소 참조하는 변수 하나도 없게되며(어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 참조 카운트), 참조 카운트가 0인 메모리 주소는 가비지 컬렉터 수거 대상이 됌
- 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화상태에 임박할 때 마다 자동으로 수거 대상들을 수거, 수거된 메ㅗ리 새로운 값 할당할 수 있는 빈 공간 됌


4. 변수 복사 비교

>- 변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일
- 단, 데이터 할당 과정에서 차이가 있으므로 변수 복사 이후 동작에 차이가 발생

5. 변수 복사 이후 값 변경 결과 비교 - 객체의 프로퍼티를 변경했을 때 

>- 기본형 데이터를 복사한 변수의 값을 바꾸면 두 변수는 다른 주소를 바라보게 됌
- 참조형 데이터를 복사한 변수의 프로퍼티값을 바꾸면 두 변수는 여전히 같은 객체를 바라봄
- 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게되는 차이

6. 변수 복사 이후 값 변경 결과 비교 - 객체 자체를 변경했을 때 

>- 참조형 데이터가 ‘가변값’라 설명할 때 ‘가변'은 참조형 데이터 자체를 변경할 경우가 아닌 내부 프로퍼티를 변경할 경우에만 성립

#### 5. 불변 객체

>
1.  불변 객체 불변 객체를 만드는 간단한 방법
- 값으로 전달 받은 객체에 변경을 가하더라도 **원본 객체는 변하지 않아야하는 경우 불변객체가 필요**

2. 얕은 복사와 깊은 복사

>
- 얕은 복사는 바로 아래 단계의 값만 복사하는 방법
- 깊은 복사는 내부의 모든 값 하나하나 찾아서 전부 복사하는 방법
- 얕은 복사는 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값 만 복사하는 것 의미
- 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소를 가리켜 즉 사본을 바꾸면 원본도 바뀌고 원본을 바꾸면 사본도 바뀜
- 한 단 계 더 들어간 변수의 내부 프로퍼티들은 기존 데이터를 그대로 참조하여
이런 현상이 발생하지 않게 하려면 변수의 내부 프로퍼티에 대해서도 불변객체로 만들 필요 있음
- 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때 객체의 프로퍼티 중 그 값이 기본형 테이터일 경우 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티를 복사해야함
- 간단한 깊은 복사 방법은 객체를 JSON 문법으로 표현된 문자열로 전환하고 다시 JSON 객체로 바꾸는 방식

#### 6. undefined와 null
- 자바스크립트에서 ‘없음’을 나타내는 값 2가지 - undefined와 null
- 두 값의 의미는 미세하게 다르고 사용하는 목적도 다름

1. undefined

>
- 자바스크립트 엔진은 사용자가 어떤 값을 지정할 것이라고 예상되는 상황임에도 그렇게 하지 않았을 때 undefined를 반환
- 다음 세가지 경우에 해당
    - 값을 대입하지 않은 변수, 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근 시
    - 객체 내부의 존재하지 않는 프로퍼티에 접근할 시
    - return 문이 없거나 호출되지 않는 함수의 실행 결과
    
2. undefined와 배열
>
- ‘비어있는 요소'와 ‘undefiend를 할당한 요소'는 출력 결과부터 다른데 ‘비어있는 요소’는 순회와 관련된 배열 메서드들의 순회 대상에서 제외
- 값이 지정되지 않은 인덱스는 아직 존재하지 않는 프로퍼티에 지나지 않음
- 값으로서 어딘가에 할당되는 undefiend은 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타냄
- undefined는 오직 값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값으로서만 존재

3. null
>
- 비어있음을 명시적으로 나타내고 싶을 땐 undefined가 아닌 null 사용
- typeof null은 object라는 것 주의, 자바스크립트 자체 버그, 비교시 일치 연산자 써사 정확히 판별


