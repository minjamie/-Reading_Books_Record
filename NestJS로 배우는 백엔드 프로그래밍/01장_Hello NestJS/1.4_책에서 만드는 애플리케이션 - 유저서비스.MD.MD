# 1.4\_책에서 만드는 애플리케이션 - 유저 서비스

---

#### 1.4.1\_모든 웹 애플리케이션의 필수 기능, 유저 서비스를 제작

![](https://images.velog.io/images/minj9_6/post/e09d22a7-87b0-43e0-84f0-ee6b65711c4c/image.png)

#### 유저 서비스는 다음과 같은 기능 제공

- 1> 회원 가입화면을 통해 유저 정보(이메일, 이름, 패스워드)를 입력받아 신규 회원 가입 처리를 수행 및 회원 정보를 데이터베이스에 저장
  [유저 가입 준비 단계]

- 2> 회원 가입 과정에서 입력 받은 이메일로 회원 가입 확인 이메일을 전송. 3> 유저는 이메일을 확인하고 회원 가입 인증을 요청 (이메일 본문 - 회원 가입 검증을 위한 요청으로서의 링크가 포함, 이 링크 회원 가입 인증 요청이 들어옴)
  [회원 가입 준비 단계에서 승인을 완료한 상태] -> [이메일 인증의 응답으로 액세스 토큰(JWT)을 전달하여 로그인 상태]
  -> 사용자가 인증 후 다시 로그인 과정을 거칠 필요가 없음
- 4> 회원 가입 완료된 사용자가 이메일과 비밀번호로 로그인 요청을 보내면 이를 처리
  -> 로그인 기능은 사용자 에이전트(브라우저, 모바일 앱 등)에게 액세스 토큰(JWT)를 발급

- 5> 사용자는 자신의 정보를 조회

#### 1.4.2\_서비스가 제공하는 기능 단순, 서비스 개발하기 위해 부가적으로 해야할 일

1> 환경 변수 설정:
서버는 보통 개발자의 로컬 개발환경, 개발된 기능을 실제 사용자에게 배포하기 전에 테스트용 서버에 배포하는 스테이지(stage)환경, 그리고 실제 운용하는 프로덕션(production) 환경으로 구성

- 각 환경에서 사용되는 변수가 달라지는 것들이 있다면 환경변수를 다르게 구성

2> 요청 유효성 검증:
프론트엔드에서 들어오는 요청은 잘못된 값을 가지는 경우가 매우 빈번 - 사용자가 값을 잘못 입력, 프론트 엔드에서 걸러지지 않은 잘못된 값이 유입 가능

- 이 경우 서버에서는 핵심 로직을 수행하기 전에 값이 제대로 전달되었는지 판단하여 만약 잘 못 전달된 경우라면 400 Bad Request 에러로 응답
  EX> 로그인 요청에서 이메일을 넣어야 하는데 이메일 형식이 아닌 문자열이 전달되면 에러로 처리

3> 인증:
사용자의 리소스에 접근하기 위해서는 권한이 필요하고 로그인 과정을 거침

- 로그인을 거친 유저는 매 요청마다 로그인을 할 필요는 없고 인증과정을 통해 후속 동작을 수행.
- 인증을 처리하는 여러가지 방법 중 토큰방식, 그 중에서도 JWT(JSON Web Token)을 이용하는 방식을 적용

4> 로깅:
서버를 운용하기 위해서는 로그를 잘 기록

- 이슈가 발생했을 때 원인을 빠르고 정확하게 파악하는 데에 로그가 매우 유용하게 사용
- 사내 사용자가 무슨 동작을 수행했는지 감사로그를 남기고 외부에 기록을 제출하는데도 쓰임

5> 헬스체크:
서버의 상태가 양호한지 주기적으로 검사

- 만약 서버 상태가 좋지 않다면 경고를 울려서 개발자가 빠르게 대응할 수 있는 방안 마련

6> CQRS(Command and Query Responsibility Segregation, 명령과 조회의 책임 분리):

- 복잡한 소프트웨어를 만들다 보면 소스 코드가 스파게티처럼 얽히게 되는 경우 발생
- 데이터베이스에 변형을 가하는 명령과 데이터 읽기 요청을 처리하는 조회 로직을 분리함으로써 성능, 확장성, 보안을 강화

7> 클린 아키텍처:
양파(Onion) 아키텍처, 육각형 아키텍처에서 발전한 클린 아키텍처, SW의 계층을 분리하고 저수준의 계층이 고수준의 계층에 의존

- 의존의 방향이 바뀌는 경우가 있다면 DIP(Dependency Inversion Principle, 의존성 역전 법칙)를 활용하여 안정적인 소프트웨어를 작성

8> 유닛 테스트:
소프트웨어에 변경이 생긴다면 반드시 테스트

- 유닛 테스트는 유저의 입장에서 수행하는 테스트가 아닌 개발자가 테스트 코드를 이용하여 수행하는 최소 단위의 테스트 기법
- 코드 조각이 동작하는 조건을 기술, 주어진 입력에 대해 원하는 결과가 나오는 지 검사
